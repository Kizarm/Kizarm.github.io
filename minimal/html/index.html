<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ARM_minimal.: Nebojme se ARM.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ARM_minimal.
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generováno programem Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Hledat');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Hlavní&#160;stránka</span></a></li>
      <li><a href="annotated.html"><span>Třídy</span></a></li>
      <li><a href="files.html"><span>Soubory</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Hledat" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Nebojme se ARM. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Fenoménem dnešní doby je v oblasti vestavných systémů přechod z 8.bitových platforem na 32.bitové, především ARM a to zejména Cortex-M. I když hlavním důvodem je asi především cena, protože poměrně dobře vybavený Cortex-M0 je možné pořídit v kusovém množství už za 1$, podívejme se i na důvody jiné.</p>
<h1><a class="anchor" id="secta"></a>
Proč nemusí být přechod na novou platformu tak bolestivý.</h1>
<p>Důvodů je hned několik. V dalším textu budeme důsledně používat volně dostupné nástroje z rodiny open source i při vědomí, že existují komfortní komerční programy, které práci na projektech velmi usnadňují. Je to ovšem otázka k diskusi, vycházíme z předpokladu (možná mylného), že je lépe vidět trochu lépe pod povrch věcí aby byly naše programy poněkud kvalitnější. Předem připravené knihovny, které lze ovšem používat i v open source nás odstiňují od podstaty, která bývá většinou dost prostá. Nakonec i některé ty komerční programy používají v jádře open source překladače, jen je to prostě dobře nastaveno a připraveno k okamžitému použití. Zásadním problémem platformy ARM není její velká složitost na níž se podepsala léta usilovného vývoje, ale spíš bídná dokumentace. Tedy ne že by nebyla, je jí však taková spousta, že vykopat z jejích hlubin ta zrnka podstatného vyžaduje spoustu úsilí. A právě to mnohé odradí. Ale není to zase tak zlé. Co budeme potřebovat (software) :</p><ol type="1">
<li><a href="http://www.gnu.org/software/binutils/" target="_blank">Binutils</a>. To je kolekce programů jež umožní překlad z jazyka symbolických adres (assembleru), sestavení výsledného obrazu kódu a jeho převedení na formát vhodný pro upload do flash cílového procesoru. Zarytý assemblerista nic víc nepotřebuje.</li>
<li>Pokud tedy nejsme masochisty, budeme se snažit použít nějaký trochu lepší jazyk pro popis problému. Sice se rozmáhá java, javascript, python, ale to není zrovna nejvhodnější pro takhle omezené systémy. Pak jsou vhodnější, ale poměrně obskurní jazyky jako forth nebo esl - viz <a class="el" href="index.html#secte">Příklad 3 - Blikáme pomocí ESL.</a> Obvykle se však používá jazyk C, i když vůči němu mají mnozí velké výhrady. Ale protože se v průběhu vývoje hodně rozšířil, je dostupný ve volné verzi na řadu různých platforem a pokud se v něm píše trochu umravněně, jednou napsaný kód lze přenést na jinou platformu s mnohem menšími potížemi než např. v čistém assembleru. Zde máme na výběr<ul>
<li><a href="http://gcc.gnu.org/" target="_blank">GCC</a> Ten je použit v příkladu, je dost propracovaný, stále se vyvíjí, dostupný pro velkou škálu platforem včetně např. AVR, PIC32 (MIPS) aj. Zmíníme ještě, že je možné pomocí něj překládat i z jiných jazyků, velmi dobře použitelný je i pro vestavné systémy C++. To zvětšuje i efektivitu práce, aniž by se to nějak negativně podepsalo na rychlosti nebo délce kódu.</li>
<li><a href="http://llvm.org/" target="_blank">clang + LLVM</a> Nový univerzální překladač se zajímavou architekturou, který zde zmiňuji především proto, že jediný nástroj umožňuje generovat kód pro různé platformy. GCC musí být pro každou platformu zvlášť přeložen. Dynamicky se vyvíjí, sleduje nové trendy (je napsán a určen především pro C++), ale zatím to vypadá, že GCC umí přece jen trochu lépe optimalizovat. Uvidíme, co ukáže budoucnost, ale obávám se, že už nyní je to obrovský moloch a bude stále růst.</li>
</ul>
</li>
<li>Nějakou C-čkovou knihovnu. Obvykle se používá <a href="https://sourceware.org/newlib/" target="_blank">Newlib</a> z dílny Redhatu, ale lze použít i jiné nebo (jako zde) se lze obejít bez ní.</li>
</ol>
<p>Pro úplnost je třeba dodat, že jak binutils, tak překladače C, C++ jsou tzv. křížové nástroje, tedy spouštějí se na jiné architektuře (zpravidla běžné PC) než pro jakou generují kód - ARM thumb, thumb2. Tyto nástroje jsou distribuovány jako zdrojové kódy a potřebné programy pak musíme zkompilovat. To je zdlouhavá procedura, která nemusí vždy vést k žádoucímu cíli. A protože to už někdo udělal za nás, využijeme toho a hotové binárky si stáhneme třeba <a href="https://launchpad.net/gcc-arm-embedded" target="_blank">zde</a>. Je zde ještě jeden dobrý důvod proč použít předkompilovaný balík - software se postupně vyvíjí, opravují se v něm chyby a přidávají nové vlastnosti. Proto je dobré používat co nejnovější. Jenže po určité době dojde k vydání nové tzv. major verze, která obsahuje především různá vylepšení, ale zase nemusí být úplně dobře odladěna. Předkompilovaný balík je určitým kompromisem - zpravidla obsahuje software, který je dost nový na práci, ale zase dost starý na to, aby v něm bylo co nejméně chyb.</p>
<p>Sice to není nezbytné, ale je dobré použít pro řízení překladu nějaký <a href="https://www.gnu.org/software/make/" target="_blank">make</a> systém. Je to použito i v tomto jednoduchém příkladu, v komentářích <a class="el" href="cblink_8c.html#make">Makefile.</a> je vidět parametry použité při překladu a sestavení. Ve Windows postačí <a href="http://www.mingw.org/" target="_blank">MinGW</a>, nemusí být ani MSYS. V Linuxu to většinou není třeba vůbec řešit, většina distribucí make obsahuje.</p>
<p><b>A jaký je tedy rozdíl mezi 8-bit platformou např. oblíbenou 8051 a ARM Cortex-M0 z hlediska aplikačního programátora ?</b> Ne zase tak obrovský, ten 32.bit je z mnohého hlediska i prostší.</p><ol type="1">
<li>Především svět ARM je většinově třívoltový, pětivoltové jsou jen výjimky. Tedy napájení je max. 3.3V, spíše však méně. I když IO piny mohou být 5V tolerantní, je lépe celý návrh přizpůsobit logice 3V. Což nemusí být problém.</li>
<li>8051 měla několik adresních prostorů (data, pdata, xdata, code, sfr, bit, sbit), které bylo nutno dost důsledně rozlišovat už při psaní kódu i když jsme si to ne vždy plně uvědomovali, protože překladač mnohé zařídil (byť ne vždy efektivně) za nás. Kdo pamatuje starší verze avr-gcc, ví jak složité bylo pracovat s konstantami, uloženými ve flash. Pojmenované adresní prostory to trochu zjednodušily, ale i tak to bylo třeba trochu hlídat. ARM má jediný 32-bitový adresní prostor a ten je (zjednodušeně řečeno) dostatečně velký, aby se tam všechno vešlo. I zde musíme ale systému říct, co má kam zapsat.<ul>
<li>Tedy že kód má být ve flash, konstanty také, ale data v RAM. To zařídí tzv. <a class="el" href="cblink_8c.html#link">Linker skript.</a> To je proti 8051 něco nového a je dobré se <a href="https://sourceware.org/binutils/docs-2.24/ld/index.html" target="_blank">naučit</a>, jak do toho vstoupit. Kdo se setkal s AVR a gcc možná něco podobného viděl, jenže tato platforma má už připravené skripty pro jednotlivé procesory, takže se o to celkem není třeba starat. Tady to moc nejde, protože typů procesorů je opravdu moc. I když jak plyne z komentářů zase tak moc se to neliší - nejvíce v definici paměťových regionů, případně názvu startovací procedury ENTRY. Zde uvedený skript je velmi zjednodušen, u větších projektů by bylo nutné dodefinovat i různé symboly pro startovací kód, který mimo jiné musí zajistit vynulování sekce bss a naplnění sekce data z flash. To je ale už nad rámec tohoto jednoduchého příkladu.</li>
<li>Registry periferií. Sice by to šlo také zařídit pomocí tohoto skriptu, ale to by bylo poměrně těžkopádné, takže se používají (v C, příp. C++) ukazatele na pevné místo v paměti. Obvykle je to vylepšeno tím, že je určitá sada registrů se společnou funkcí deklarována jako struktura viz např. <a class="el" href="structGPIO__Type.html">GPIO_Type</a>. Ani to není dramatický rozdíl, jde o zvyk.</li>
<li>Zmíníme ještě přístup k jednotlivým bitům. 8051 na to měla specifickou oblast RAM (ale i SFR), kde šlo zapisovat a číst bity atomicky. U Cortex-M3,4 je něco podobného zachováno, je však nutné podotknout, že u některých typů i když je tato funkce v jádře zachována, chybí potřebný kus RAM, takže to nefunguje. Zatím jsem ale nenarazil na příklad, kde by se to dalo smysluplně využít.</li>
</ul>
</li>
<li>Složitější periferie. To je nejčastější námitka. Když se do toho ale obujeme pořádně, zjistíme, že základní funkce periferií je možné aktivovat zapsáním několika málo bitů do registrů. Nad složitějším chováním periferie je nutné se poněkud zamyslet a nastudovat referenční manuál. Výrobce sice většinou poskytuje periferní knihovny, ale pokud tyto mají postihnout všechny složitosti, jsou pak rovněž komplikované a požadované jednoduché chování se v tom úplně ztratí. Nehledě na to, že z dokumentace k periferním knihovnám stejně většinou nezjistíme, jak přesně zajistit požadovanou funkci. Je to dáno především tím, že knihovny výrobce tvoří jakoby "odspodu", tedy z hlediska hardware, nikoli podle potřeb toho, kdo to pak bude používat. Druhý extrém jak vyřešit problém je styl "Arduino". Zde zase máme sadu funkcí, které lze jednoduše používat, ale pokud chceme trochu odlišné chování, je nutné zasáhnout přímo do knihovny. Což by ani nebylo na závadu, ale tento styl je bohužel doveden ad absurdum (např. předdefinováním statických tříd pro periferie, ale je tam spousta dalších podivností), takže i tento systém má řadu odpůrců. Čili dokonalý systém nechme budhistům a jiným hledačům absolutní pravdy. <br />
 V našem příkladě je jediné co je nutno udělat navíc - pustit přes <a class="el" href="structRCC__Type.html">RCC_Type</a> do periferie hodinové pulsy, aby vůbec chodila. To platí pro všechny periferie, při jejich velkém množství je skutečně lépe je "odstavit", pokud nejsou používány. Na druhou stranu bývají nové procesory vybaveny periferiemi, které ve starších řadách nebyly a bylo nutné připojit externí řadič. S výhodou se dá použít např. USB nebo Ethernet. Knihovny pro obsluhu těchto složitých periferií bývají k dispozici na stránkách výrobce, případně zašity přímo do ROM procesoru.</li>
<li>Přerušovací systém, který zde téměř nepoužíváme (jen start programu, reset) je u Cortex-M vlastně jednodušší. Vektory, tedy vlastně adresy obslužných rutin, jsou (zjednodušeně) také na pevných adresách (opět <a class="el" href="cblink_8c.html#link">Linker skript.</a>), obslužné rutiny mohou však být jednoduché C funkce typu <b>void Handler (void)</b>, hardware je tomuto přizpůsobeno. Procesory Cortex-M byly navrženy tak, aby bylo možné napsat celý kód v jazyce C a překladač nemusel používat různé obezličky pro uschování registrů, když program vstoupí do přerušení. Sice to poněkud zdržuje, ale funguje to. Detaily zde nebudeme probírat, nejsou pro nás příliš důležité.</li>
<li>Instrukční sada je samosebou jiná. Zajímavé je, že u 32.bitového procesoru může být použita 16.bitová instrukční sada. Šířka slova instrukcí tedy se šířkou slova, s níž pracuje aritmeticko-logická jednotka (ALU) nesouvisí. Označení o kolika bitový procesor se jedná se vztahuje právě na ALU, tedy na výpočty. Zase tak moc divné to není, třeba AVR, označované jako 8.bitové mají instrukce také 16.bitové. U Cortex-M je pouze 16.bitová thumb, resp.thumb2 sada instrukcí, pravý 32.bit ARM to neumí. Šetří se tak místo ve flash. Ale protože je to RISC, moc se toho neušetří, takže výsledný kód je delší. Obvykle mají tyto procesory zase větší flash. V neposlední řadě je třeba uvažovat 32.bitovou aritmetiku - ta samosebou značně zkrátí a urychlí výpočty s větší šířkou slova než 8 bitů. A těch je většina.</li>
<li>A nakonec jak dostat program do cílového procesoru. Jak postupně nahradily pevné paměti (E)EPROM paměti typu FLASH, i 8-bitové procesory začaly používat sériové rozhraní pro programování. U ARM (a jiných) je tato myšlenka dovedena poněkud dále. Standardem se stalo rozhraní JTAG (4 dráty a zem), přičemž vnitřní struktura umožňuje různé ladící funkce - od otestování vodivého spojení pinů (boundary scan) po úplné ovládání interního programu včetně breakpointů a watchpointů. Kromě toho pro zavedení programu do paměti bývá v čipu i kousek pevné paměti ROM, obsahující zavaděč využívající různé dostupné periferie (přes USART po USB) podobně jako to uměly už ty 8.bity. A aby to nebylo zase tak jednoduché, začalo se šetřit vývody a místo JTAG se u Cortex-M používá SWD - 2 dráty a zem (minimálně, může obsahovat i reset, není však nutný). JTAG bývá osazen také, sdílí piny se SWD, ale ne vždy a ne vždy plnohodnotný. U některých typů bývá JTAG použit jen pro boundary scan. Pro SWD už nelze použít nějaký "hrdzavý klinec", je potřeba dost sofistikovaný hardware i software. Vývojové kity takový hardware obsahují - např. zde použitý Discovery kit má tzv. ST-Link. Co se týče software je i zde několik možností. Z vyzkoušených uvedeme:<ul>
<li><a href="http://openocd.sourceforge.net/" target="_blank">OpenOCD</a> Podporuje širokou paletu cílových procesorů, tak JTAG/SWD hardware jako je ST-Link. Software funguje jako server na který se lze připojit telnetem nebo pomocí <a href="https://www.sourceware.org/gdb/" target="_blank">gdb</a>, což je debuger, ovládaný z příkazové řádky. Umožňuje to poměrně komfortní ladění, což bylo třeba na 8051 možné jen pomocí dost drahého emulátoru. Gdb bývá součástí toolchainu pro ARM, v balíku z launchpad.net je obsaženo.</li>
<li><a href="http://www.blacksphere.co.nz/main/blackmagic" target="_blank">Black Magic probe</a> Tohle je už pro zkušenější uživatele. Je v tom finta - gdb server běží přímo v procesoru sondy. Lze to flashnout i do toho ST-Linku, ale operace je nevratná. Znamená to o vrstvu software méně, ale není podporováno tolik typů procesorů. Z funkčního hlediska je to možná o něco lepší než OpenOCD.</li>
<li>pro úplnost ještě můžeme zmínit, že některé procesory např. NXP mají vcelku šikovný bootloader, který po připojení jako USB device v počítači vytvoří virtuální disk, na který binární obraz systému prostě nakopírujeme. Nepotřebujeme tedy vůbec žádný hardware. Na tomto systému je založen klon blackmagic, který lze stáhnout <div class="fragment"><div class="line">svn checkout svn:<span class="comment">//svn.code.sf.net/p/kizarmprobe/code/ kizarmprobe</span></div></div><!-- fragment --> Nebo lze použít odkaz na <a href="http://sourceforge.net/projects/kizarmprobe/">této stránce</a>, kde můžete najít i stručný <a href="http://kizarmprobe.sourceforge.net/html">popis</a>. Gdb server pak může běžet v levném čipu LPC11U24 (34) a tímto systémem můžeme v jiném čipu (nemusí být nutně NXP) ladit programy. Je to tedy jakýsi podomácku vyrobitelný bootstrap pro začátek práce s Cortex-Mx.</li>
</ul>
</li>
</ol>
<p>Programů pro debug a upload firmware do cílového procesoru je samosebou více, na webu lze najít mnoho možností. JTAG, příp. SWD znamená použít dost složitý řetězec hardware a software, což je náročné na nastavení. Na druhou stranu získáme dobrou kontrolu nad cílovým procesorem pomocí několika málo pinů. Zde je dobré ještě podotknout, že pokud chceme např. SWD používat, nelze pak už použité piny využít v aplikaci k ničemu jinému. <b>Možnost ladění přímo v cílovém procesoru pomocí relativně levného hardware je snad největší přínos těchto nových typů procesorů a to nejen ARM.</b> To je proti 8051 neskutečný komfort, i když standardní techniky ladění za běhu pomocí výpisů na sériový (ale i jiný) port nebo nastavováním IO pinu se samosebou používají i zde. Jak je zmíněno dále v textu, <b>program může běžet i v RAM</b>. Což většinou 8-bitové uP neumožňovaly. Pro ladění je to docela dobrá možnost, výhodou je, že je to rychlejší a "neošoupáte" flashku, nevýhodou je že RAMka je menší, tedy se toho tam moc nevejde a potřebuje to speciální nastavení bootovacího režimu, které se u jednotlivých typů liší, u některých je poměrně obtížné.</p>
<h1><a class="anchor" id="sectb"></a>
Příklad 1 - Naprosto minimální blikání LEDkou na STM32F0 nebo STM32F4 Discovery.</h1>
<p>Viz <a class="el" href="cblink_8c.html#codec">Celkový kód v C nebo C++.</a> Základní hodiny jádra ani FLASH se nenastavují, zůstávají na default hodnotách. Prostě se využije toho, že nějaké hodiny se do jádra zavést musí automaticky aby se to vůbec rozběhlo. <b>Není to ale dobrá praktika</b>, hodiny je lépe přesně specifikovat a správně nastavit FLASH také není od věci. Zde je to jen pro maximální zkrácení kódu vynecháno. C-čkový zdroják je asi zbytečně ukecaný aby bylo vidět, že dobře funguje optimalizace.</p>
<h1><a class="anchor" id="sects"></a>
Příklad 2 - Blikáme pomocí systémového časovače.</h1>
<p>Viz <a class="el" href="cblink_8c.html#codet">C-čkový kód pro blikání pomocí systémového časovače.</a> Tento příklad umožňuje přesněji nastavit čas blikání. Úplně přesně to není, stále používáme default hodiny a ty jsou HSI, což je interní RC oscilátor procesoru. Nicméně to ve většině případů stačí, nepřesnost by neměla přesáhnout asi jedno procento. HSI má na F0 frekvenci 8MHz, na F4 16HMz, tedy hodně pod mezí jádra a není potřeba externí krystal. Zde už použijeme CMSIS pro nastavení systémového časovače. Kód tím poněkud naroste - musíme použít větší tabulku vektorů (minimálně až po SysTick_Handler), inicializace časovače také něco stojí. CMSIS je knihovna určená pro ovládání jádra (nikoli periferií) Cortex M procesorů. Byla vytvořena přímo ARM Company (resp. Keil), je celkem dobře a úsporně napsána a je k dispozici jako zdrojové texty v jazyce C. Jinak je kód stejně jednoduchý jako v předchozím případě. Protože vlastní bliknutí probíhá v přerušení, lze procesor v hlavní smyčce uspat, čímž se sníží spotřeba. Pro ARM je celkem běžná praktika, že celá činnost zařízení (pokud je to možné) probíhá v přerušení a hlavní smyčka bývá prázdná. Něco málo k tomuto viz <a class="el" href="main_8cpp.html#intrmain">Softwarové přerušení</a></p>
<p>Pozn.<br />
Program může běžet ve FLASH i RAM, pro běh v RAM nutno nastavit BOOT1 (v option bytes, což není tak jednoduché pro F0, propojkou na F4) a BOOT0 pin na VCC a upravit script.ld (sekce .fixed &gt;RAM ).</p>
<h1><a class="anchor" id="secte"></a>
Příklad 3 - Blikáme pomocí ESL.</h1>
<p><a href="https://code.google.com/p/esl/" target="_blank">ESL</a> je takový hybrid slepený z C, Pascalu a asi i něčeho jiného. Původně to však mělo být určeno především pro vestavné systémy. Pracuje to nad <a href="http://llvm.org/" target="_blank">LLVM</a>, takže kdo používá clang má základ už nainstalovaný. Nainstalovat nad tím ESL by neměl být problém, ale překladač je napsán celý v tomto jazyce, takže je nutné mít nějakou prvotní verzi tohoto překladače (problém vejce a slepice), což nefunguje ve Windows. Snad jedinou výhodou tohoto jazyka je lepší přístup k periferiím, umožňuje např. indexovat bitová pole, což v C neuděláte. Pak je program lépe strukturován a tím i čitelnější. Dále je možné definovat volatilitu pro čtení i zápis, a zřejmě to má i některé další užitečné atributy, které jsem neobjevil. Nevýhody převažují</p><ul>
<li>jazyk je poměrně obskurní, takže ho patrně používá jen omezená množina programátorů.</li>
<li>není dokončena dokumentace</li>
<li>problematické je debugování, možná se zlepší</li>
<li>zatím také není (nebo nefunguje) alespoň nějaká rozumná optimalizace. Něco jde udělat pomocí LLVM opt, ale do C-čka to má daleko.</li>
<li>chtělo by to lepší textový editor, zkrátka chybí infrastruktura.</li>
</ul>
<p>Nicméně chvíli jsem si s tím hrál, celkem to funguje, takže pro ostatní průkopníky slepých uliček jsem to zařadil bez bližších komentářů <a href="../esl.tar.xz">sem</a>. Pro ukázku stejné blikátko</p>
<div class="fragment"><div class="line">/**</div><div class="line"> * Tohle je velmi zjednodušené blikátko,</div><div class="line"> * fungující na STM32F0 a STM32F4 Discovery (v RAM, ale po úpravě script.ld patrně i ve FLASH).</div><div class="line"> * Systém se nijak nenastavuje, hodiny jsou default HSI. V definicích použitých periferií je</div><div class="line"> * většina registrů a jejich obsahu ignorována, bylo by to moc psaní.</div><div class="line"> */</div><div class="line">// Připoj package sys</div><div class="line">import sys;</div><div class="line">// Čekaní odečítáním, není moc efektivní</div><div class="line">proc Delay (time: _uint) {</div><div class="line">  var count: _uint: in, out; // volatile</div><div class="line">  count = time;</div><div class="line">  while count &gt; 0 do {count = count - 1;};</div><div class="line">}</div><div class="line">// Hlavni procedura se musí nějak navázat na Reset_Handler.</div><div class="line">// Lze ji tak přímo pojmenovat a je hotovo. Ty vektory by asi</div><div class="line">// nějak šly udělat i v tomto jazyce, ale nechme to být.</div><div class="line">// V původním pramenu to dělají v assembleru, C-čko je přehlednější.</div><div class="line">proc main(): : weak(&quot;Reset_Handler&quot;) {</div><div class="line">  sys.Init ();          // jen zapne hodiny a nastaví LED jako výstup</div><div class="line">  while true do {</div><div class="line">    sys.toggle ();      // přepni LED</div><div class="line">    Delay (sys.times);  // počkej</div><div class="line">  };</div><div class="line">}</div></div><!-- fragment --><p>a jednoduchá obsluha periferií</p>
<div class="fragment"><div class="line">package sys {</div><div class="line">  // definice registru</div><div class="line">    type Mode: (                        // enumerace modu zabere pakovana 2 bity</div><div class="line">      INPUT, OUTPUT, ALTERNATE, ANALOG</div><div class="line">    );</div><div class="line">    type GPIORegs: {</div><div class="line">      // indexovane pole dvoubitovych elementu v C nejde udelat, zde ano</div><div class="line">      moder: [16]Mode: packed, lsb, out;</div><div class="line">      otyper: _uint32: out;</div><div class="line">      ospeed: _uint32: out;</div><div class="line">      pupdr:  _uint32: out;</div><div class="line">      idr:    _uint32: in;</div><div class="line">      odr:    _uint32: in, out;</div><div class="line">//    odr:[32]boolean: packed, lsb, in, out;</div><div class="line">      bsrr:   _uint32: out;</div><div class="line">      lckr:   _uint32: out;</div><div class="line">    };</div><div class="line">    var gpioc: GPIORegs: external(0x4800_0800);</div><div class="line">    type RCCRegs: {</div><div class="line">      _ : [5] _uint32;                  // ignorujeme</div><div class="line">      // nic jineho neni potreba, napiseme to jako bitove pole</div><div class="line">      ahbenr: {</div><div class="line">        _ : [17] boolean;               // ignorujeme</div><div class="line">        gpioaen: boolean;</div><div class="line">        gpioben: boolean;</div><div class="line">        gpiocen: boolean;</div><div class="line">        gpioden: boolean;</div><div class="line">        // atd., zbytek neni take potreba</div><div class="line">        _ : [11] boolean;               // ignorujeme</div><div class="line">      }: packed, lsb, out;</div><div class="line">      apb2enr: _uint32: out;</div><div class="line">      apb1enr: _uint32: out;</div><div class="line">      // atd. nebo jako boolean pole</div><div class="line">    };</div><div class="line">    var rcc:   RCCRegs:  external(0x4002_1000);</div><div class="line">  // procedury</div><div class="line">    const led   = 8;                     // modra LED na portu C</div><div class="line">    const times = 100000;                // zpozdeni</div><div class="line"></div><div class="line">    proc Init () {</div><div class="line">      rcc.ahbenr.gpiocen = true;</div><div class="line">      gpioc.moder[led]   = OUTPUT;       // tohle v C-cku nejde</div><div class="line">    };</div><div class="line">    proc toggle () {</div><div class="line">      gpioc.odr = gpioc.odr ^ (0x1 &lt;&lt; led );</div><div class="line">// Tenhle zapis funguje take, pokud odr definujeme jako pole boolean, ale neni tak efektivni</div><div class="line">//    gpioc.odr[led] = ~gpioc.odr[led];</div><div class="line">    };</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="sectd"></a>
Příklad 4 - Blikáme pomocí jazyka D.</h1>
<p><a href="https://dlang.org/getstarted.html" target="_blank">Jazyk D</a> vznikl jako logické pokračování C++. Podle autorů specifikace by měl odstranit některé chyby v návrhu jazyka C++ ale je těžké posoudit jaké. Jazyk D podporuje nízkoúrovňové programování, má garbage collector podobně jako třeba java, C#, ale překladač produkuje nativní kód a garbage collector se dá vypnout. Průkopnická práce pro STM32 je <a href="https://github.com/JinShil?tab=repositories" target="_blank">zde</a>. Je vidět, že po světě jsou různí podivíni. Věnoval jsem tomu trochu času, <a href="../gdc.tar.xz">blikátko</a> máme - pár postřehů:</p><ul>
<li>Funguje to, produkovaný kód není ani moc šílený.</li>
<li>Existují nástroje na bázi <a href="https://github.com/JinShil/arm-none-eabi-gdc" target="_blank">gcc</a>, LLVM a to i na křížovou kompilaci pro ARM.</li>
<li>Periferie se dají uspořádat dost přehledně, ale připomíná to spíše lingvistické cvičení než cokoli jiného. Takže to jde přeložit jen pomocí gdc, ldc (LLVM) si s tím neporadí (nebo nevím jak).</li>
<li>Pokud se podíváte do zdrojáků, vidíte spoustu různých workaroundů pro vestavné systémy. Dá se říct jde to ale dře to.</li>
<li>Podle mého soudu je jazyk D moc složitý než aby v něm šlo pohodlně programovat. Ti, kdo ho navrhovali do něj vložili vlastnosti, které bych osobně raději viděl jako uživatelské konstrukce (příp. knihovní funkce), které mohu použít nebo taky ne, pokud je nepotřebuji.</li>
</ul>
<p>Zatím to vypadá jako další slepá ulička nebo šílenost pro nadšence, ale rozvíjí se to. Rozhodně je to pro malé kontroléry vhodnější než java. I když ta je tak rozšířená, že nakonec prorazí spíš a to i navzdory té nevhodnosti. Už teď existují jednoduché JVM pro tyto účely.</p>
<h1><a class="anchor" id="sectr"></a>
Příklad 5 - Blikáme pomocí jazyka rust.</h1>
<p>Vycházím z <a href="https://github.com/cbiffle/minimal-embedded-rust" target="_blank">tohoto projektu</a>, dodělal jsem do toho minimální blikání na STM32F4 Discovery ve stylu předchozích příkladů. Vyzkoušeno to bylo na Ubuntu 16.04, rust je nainstalován pomocí skriptu příkazem </p><div class="fragment"><div class="line">curl https:<span class="comment">//sh.rustup.rs -sSf | sh</span></div></div><!-- fragment --><p> Dál se jen řídit pokyny README v rozbaleném <a href="../rust.zip">archivu</a>. Rust stejně jako většina novějších jazyků používá vlastní build systém (zde cargo), který je poměrně složitý (a tedy nepochopitelný), ale není nutné se o to nějak starat, v projektu je to už zahrnuto.</p>
<ul>
<li>Vyzkoušení módního jazyka není na škodu. Rust je obecně deklarován jako "bezpečný". Tím by mělo odpadnout mnoho pravidel, která je nutné používat v C pro lepší bezpečnost a přenositelnost kódu, tady to ohlídá překladač. Bohužel zavedené restrikce v jazyce rust jsou pro přímý přístup na hardware dost omezující, takže většina kódu je stejně uzavřena do bloku unsafe.</li>
<li>Pro přímý přístup do registrů je v C zavedena metoda, deklarující registry jako volatile, což stačí k tomu, aby zamezil překladači optimalizaci. V rustu to asi taky nějak jde, ale jak jsem zkoumal zdrojáky <a href="https://github.com/hackndev/zinc" target="_blank">zinc</a>, je to komplikované. Zinc se mi nepodařilo rozchodit, takže je vidět, že i s přenositelností to nebude nijak slavné. Nakonec se podařilo použít samostatné <a href="https://crates.io/crates/volatile_cell" target="_blank">VolatileCell</a>, což asi pochází také ze zinc, zde to funguje.</li>
<li>Délka produkovaného kódu je zhruba stejná jako v C, záleží na optimalizaci a ta je také záležitostí LLVM. Na tomto jednoduchém příkladu je zřejmé, že je to celkem efektivní, je zapnuta optimalizace i v debug módu, takže release se liší jen nepřítomností ladících informací. Otázkou zůstává, jak se s tím poradí normální gdb (pro rust se asi nějak upravuje).</li>
<li>Otázka použitelnosti není na tak malém příkladu relevantní. Příklad zinc je však varováním, že to nebude tak jednoduché. Pro mne osobně je zatím C++ lepší variantou, tahle cestička je už dost dobře prošlapaná i pro dost velké projekty. Nicméně není vidět žádná překážka, která by vážně bránila rust pro Cortex-Mx používat.</li>
</ul>
<p>Nechme to uzrát, zkoušel jsem jazyk D (rust mi ale přijde o něco lepší i když se od skupiny jazyků C dost liší, v něčem mi připomíná spíš python), taky to fungovalo a skoro nikdo to nepoužívá, většina lidí je konzervativní a zůstává u čistého C. Tyhle nové jazyky jsou možná dobré pro normální programovaní na PC, na malých procesorech bývají problémy, které musí řešit někdo, kdo ovládá jak ten jazyk (včetně struktury překladače), tak všechna úskalí vestavných systémů. Ten průnik bývá malý. Je zřejmé, že Mozilla do toho investovala dost úsilí, pokud to bude opravdu tak stabilní a efektivní jak slibují, tak se to ujme, pro automotive a vše, kde se klade důraz na bezpečnost by to mohla být dobrá volba. Struktura jazyka hodně brání nebezpečným konstrukcím, a pokud je programátor použije, snadno se v kódu dají dohledat. Skoro by se dalo říct, že ty MISRA pravidla jsou už uvnitř, hlídá je překladač. Ale MISRA nebo podobné restrikce je možné zabudovat i do překladačů C a C++, jsou na to nástroje např. v clang.</p>
<h1><a class="anchor" id="sectz"></a>
Závěr</h1>
<p>Ten jednodušší program s optimalizací -Os (C i C++, binárky jsou stejné - alespoň v mé verzi GCC) má jen 56 bytů. V assembleru (ablink.s) 48 bytů. Pro srovnání a zaryté assembleristy viz <a class="el" href="cblink_8c.html#codes">Celkový kód v Assembleru.</a> Celkem na tom není co ušetřit. Přece jen je to RISC, takže ldr, str se pořád opakuje. Srovnejte si to s překladem z C nebo C++ a disassemblovaným výstupem cblinking.lst (bblinking.lst). Není to tak velký rozdíl - optimalizovaný překlad z C nebo C++ je velmi efektivní. Složitější příklad, pracující se systémovým časovačem je zhruba 3x větší (záleží na procesoru - pro CM4 je o něco menší).</p>
<p>Je zřejmé, že to není až taková věda a kódu také nemusí být plná FLASH. A protože cena Cortex-M0+ začíná být příznivá, nic nebrání tomu přejít na tuto platformu i pro jednoduchá udělátka, kde by se mohlo zdát, že je to dělo na komára. Sice opravdu je, ale je to jen příklad, této funkce by se dalo dosáhnout se dvěma tranzistory a několika málo pasivními prvky.</p>
<p>Samosebou vývoj takhle minimalistické aplikace je spíš jen pro ukázku, že to jde. Normální lidi používají standardní periferní knihovny výrobce procesoru. Je to celkem pohodlné, zkoušel jsem si v Cube naklikat jen to nezbytně nutné pro blikání LEDkou, je fakt, že to trvá pár minut, funguje to a vygenerovanému kódu pak stačí přidat např. takovouto triviální funkci : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;stm32f0xx_hal.h&quot;</span></div><div class="line"><span class="keywordtype">void</span> HAL_SYSTICK_Callback(<span class="keywordtype">void</span>) {</div><div class="line">  <span class="keyword">static</span> uint32_t count;</div><div class="line">  <span class="keywordflow">if</span> (++count &gt;= 500) {</div><div class="line">    count = 0;</div><div class="line">    HAL_GPIO_TogglePin (GPIOC, 1&lt;&lt;8);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> a je hotovo. Problém je, že délka programu naroste zhruha na 3 KiB i při zapnuté optimalizaci -Os. Možná to někomu nevadí, ale mně to připadá už dost přehnané. Přece jen se nastavuje jen pár bitů v registrech periferií. Sice o něco víc než v předchozích případech, ale chybu bych v tom pak hledat nechtěl. Najít co vlastně máme napsat jako uživatelský kód je sice méně práce než nastudovat referenční manuál, v případě problému ale stejně nic jiného nezbyde a chyba v cizím kódu se hůř hledá. Nehledě na to, že pokud chceme naklikat ty periferie správně, pak stejně musíme mít nějaké základní povědomí z referenčního manuálu jak.</p>
<p>Sílu 32. bitového procesoru oceníme spíš při výpočtech. Tedy digitální filtry, regulátory a jiné typické aplikace. Pak je možné nasadit jednočip i tam, kde se o tom v časech 8.bitů ani nesnilo. Velkou výhodou v dnešní době je i to, že se není třeba tolik trápit s optimalizací kódu. Byly aplikace, kde se počítalo s každou jednotlivou instrukcí a funkce přímo závisela na přesném časování. Zde tento přístup nelze dost dobře uplatnit. Časování jednotlivých instrukcí není přísně vzato deterministické - vstupuje zde do hry např. pipeline, délka operace násobení může záviset na operandech atd. Čili změna přístupu ke kódování je nutná, ale jak jsme se snažili ukázat, není to nic dramatického.</p>
<p>V neposlední řadě jsem se snažil ukázat na velmi jednoduchém příkladě, jak používat open-source nástroje pro řízení projektu s vestavnými systémy. To, co je zde popsáno, principiálně postačuje pro řízení libovolně složitého projektu. To, že přibudou nějaké startup rutiny, pár řádek do linker skriptu a maličko se změní Makefile vlastně není podstatné. Je to ostatně vidět - i zde přechod z F0 na F4 požaduje změnu jen pár řádek v definici periferií. <b>Podstatné je, že takto v principu funguje překlad a sestavení programu pomocí gcc toolchainu de facto pro libovolnou architekturu, pro kterou je určen</b>. Tedy nejen ARM, ale i AVR, MIPS, MSP430 a další. Pokud pochopíme tento princip, není třeba trápit se s nastavováním různých více či méně povedených IDE. Dokumentace použitých nástrojů není sice dokonalá, ale dá se s trochou praxe naučit i dost pokročilá nastavení, na která IDE nemusí vždy pamatovat. Škoda, že se touto zásadou neřídí tvůrci knihoven s otevřeným zdrojovým kódem. Když tak prohlížím příklady z Internetu, najdu projekty pro různorodá IDE, ale aby k tomu autor přibalil obyčejný makefile, to ho obvykle ani nenapadne. A když už se vyskytne čestná výjimka, jsou tam zase patrně pro zmatení nepřítele různě rozesety absolutní cesty k souborům, což sice dobře funguje autorovi, ale už nikomu jinému. Z dlouholeté zkušenosti bych si dovolil tvrdit, že IDE se mění, ale dobře navržený ručně napsaný makefile zůstává. A není pak takový problém přenést projekt z jednoho prostředí do druhého, většina IDE si s tím poradí. Pro malé úpravy pak není ani to IDE potřeba, stačí libovolný textový editor.</p>
<p>Nakonec přibalíme i <a href="../minimal.tar.xz">zdrojové kódy</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generováno st 27. zář 2017 08.34:12 pro projekt ARM_minimal. programem &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
